<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Antoine Prouvost</title>
    <link>https://www.prouvost.dev/post/</link>
    <description>Recent content in Posts on Antoine Prouvost</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© Antoine Prouvost</copyright>
    <lastBuildDate>Sat, 29 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.prouvost.dev/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why Conda?</title>
      <link>https://www.prouvost.dev/post/2020/why-conda/</link>
      <pubDate>Sat, 29 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.prouvost.dev/post/2020/why-conda/</guid>
      <description>If you have written or used scientific software, especially in Python, you have probably been told to use Anaconda without much explanations, only to find yourself frustrated by conda slowness and inflexibility. Why is that? And what is the difference between pip install numpy and conda install numpy anyways?
Conda is a general purpose cross language package manager tailored to deal with the extensive binary compatibility requirements of scientific software. In this blog post, I will detail what those requirements are and what Conda is doing different as a package manager to meet them.</description>
    </item>
    
    <item>
      <title>Minimal ABI Example</title>
      <link>https://www.prouvost.dev/post/2020/minimal-abi-example/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.prouvost.dev/post/2020/minimal-abi-example/</guid>
      <description>In compiled languages, such as C++, developpers have the possibility to use and build shared libraries, also known as a dynamic libraries. To depend on a shared library (in an exectuable or another shared library), said library needs to be present at compile time, 1 but really symbols from the library (functions, types, global variables etc.) are resolved at runtime (when something is executed) by the dynamic linker.
Shared libraries have many advantages.</description>
    </item>
    
  </channel>
</rss>